<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoDash Pro</title>
    <style>
        :root { --primary: #00f2ff; }
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #0a0a0a; color: white; }
        
        /* Menu Styling */
        #ui-layer { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.6); z-index: 10; transition: 0.5s; }
        .hidden { display: none !important; }
        
        h1 { font-size: 80px; margin: 0; color: var(--primary); text-shadow: 0 0 20px var(--primary); letter-spacing: 5px; font-style: italic; }
        
        .panel { background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); text-align: center; width: 400px; }
        
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 20px; }
        button { padding: 12px; cursor: pointer; background: var(--primary); border: none; color: black; border-radius: 5px; font-weight: bold; transition: 0.3s; text-transform: uppercase; }
        button:hover { transform: scale(1.05); box-shadow: 0 0 15px var(--primary); }
        button.level-btn { background: #555; color: white; }
        button.level-btn:hover { background: #777; }

        .custom-section { display: flex; justify-content: space-around; align-items: center; margin: 15px 0; }
        .face-opt { font-size: 30px; cursor: pointer; opacity: 0.5; transition: 0.3s; }
        .face-opt.active { opacity: 1; transform: scale(1.2); text-shadow: 0 0 10px white; }
        
        input[type="color"] { border: none; width: 40px; height: 40px; background: none; cursor: pointer; }

        canvas { display: block; filter: drop-shadow(0 0 5px rgba(0,242,255,0.2)); }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>GEODASH</h1>
        
        <div class="panel" id="main-menu">
            <div class="custom-section">
                <div class="face-opt active" onclick="setFace('happy', 0)">游땕</div>
                <div class="face-opt" onclick="setFace('neutral', 1)">游땛</div>
                <div class="face-opt" onclick="setFace('sad', 2)">驕좶잺</div>
                <input type="color" id="pColor" value="#00f2ff" onchange="updateColors()">
            </div>

            <div class="btn-grid">
                <button onclick="startGame('level1')" class="level-btn">Level 1</button>
                <button onclick="startGame('level2')" class="level-btn">Level 2</button>
                <button onclick="startGame('level3')" class="level-btn">Level 3</button>
                <button onclick="startGame('endless')" style="grid-column: span 2;">Endless Run</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- HERN칄 PREMENN칄 ---
        let gameState = 'menu';
        let currentLevel = null;
        let score = 0;
        let distance = 0;
        let speed = 7;
        let playerFace = 'happy';
        let pColor = "#00f2ff";
        
        let bgColor = { r: 20, g: 20, b: 35 };
        let targetBg = { r: 20, g: 20, b: 35 };

        const gravity = 0.8;
        const jumpPower = -14;
        const groundY = canvas.height * 0.7;

        let player = {
            x: 150, y: groundY - 50, size: 50,
            vy: 0, rotation: 0, isJumping: false,
            targetRot: 0
        };

        let obstacles = [];
        let particles = [];

        // Defin칤cia levelov (X s칰radnice prek치쬺k)
        const levels = {
            level1: { obstacles: [800, 1200, 1500, 1900, 2000, 2500, 2800, 3100, 3150, 3200], color: [0, 150, 255], end: 4000 },
            level2: { obstacles: [800, 1100, 1150, 1600, 2000, 2100, 2500, 2600, 2700, 3000, 3500], color: [46, 204, 113], end: 4500 },
            level3: { obstacles: [800, 900, 1000, 1500, 1800, 1900, 2400, 2500, 2600, 3000, 3100, 3500, 3600], color: [231, 76, 60], end: 5000 }
        };

        // --- LOGIKA MENU ---
        function setFace(face, idx) {
            playerFace = face;
            document.querySelectorAll('.face-opt').forEach((el, i) => {
                el.classList.toggle('active', i === idx);
            });
        }

        function updateColors() {
            pColor = document.getElementById('pColor').value;
            document.documentElement.style.setProperty('--primary', pColor);
        }

        function startGame(mode) {
            gameState = 'playing';
            currentLevel = mode;
            uiLayer.classList.add('hidden');
            resetGame();
        }

        function resetGame() {
            score = 0;
            distance = 0;
            speed = 7;
            player.y = groundY - 50;
            player.vy = 0;
            player.rotation = 0;
            player.targetRot = 0;
            obstacles = [];
            
            if(currentLevel !== 'endless') {
                levels[currentLevel].obstacles.forEach(ox => {
                    obstacles.push({ x: ox, type: 'spike' });
                });
            }
        }

        // --- GRAFIKA ---
        function lerpColor() {
            bgColor.r += (targetBg.r - bgColor.r) * 0.01;
            bgColor.g += (targetBg.g - bgColor.g) * 0.01;
            bgColor.b += (targetBg.b - bgColor.b) * 0.01;
        }

        function drawCube(x, y, size, rot, color, face) {
            ctx.save();
            ctx.translate(x + size/2, y + size/2);
            ctx.rotate(rot * Math.PI / 180);
            
            // Telo
            ctx.shadowBlur = 15;
            ctx.shadowColor = color;
            ctx.fillStyle = color;
            ctx.fillRect(-size/2, -size/2, size, size);
            
            // Detaily (vn칰torn칳 코tvorec)
            ctx.strokeStyle = "rgba(255,255,255,0.5)";
            ctx.lineWidth = 3;
            ctx.strokeRect(-size/2 + 5, -size/2 + 5, size - 10, size - 10);

            // Smajl칤k
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.beginPath();
            if(face === 'happy') {
                ctx.strokeRect(-12, -15, 2, 6); ctx.strokeRect(10, -15, 2, 6);
                ctx.arc(0, 5, 12, 0.2, Math.PI - 0.2, false);
            } else if(face === 'neutral') {
                ctx.strokeRect(-12, -15, 2, 6); ctx.strokeRect(10, -15, 2, 6);
                ctx.moveTo(-12, 12); ctx.lineTo(12, 12);
            } else {
                ctx.strokeRect(-12, -15, 2, 6); ctx.strokeRect(10, -15, 2, 6);
                ctx.arc(0, 20, 10, 0, Math.PI, true);
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawSpike(x, y, size) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = "#ff2222";
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size, y);
            ctx.lineTo(x + size/2, y - size);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = "#ff4444";
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // --- HLAVN칗 CYKLUS ---
        function update() {
            if(gameState === 'playing') {
                distance += speed;
                player.vy += gravity;
                player.y += player.vy;

                // Rot치cia
                if(player.isJumping) {
                    player.rotation += 6; 
                }

                if(player.y > groundY - player.size) {
                    player.y = groundY - player.size;
                    player.vy = 0;
                    player.isJumping = false;
                    player.rotation = Math.round(player.rotation / 90) * 90;
                }

                // Endless generovanie
                if(currentLevel === 'endless' && Math.random() < 0.02 && (obstacles.length === 0 || obstacles[obstacles.length-1].x < canvas.width - 300)) {
                    obstacles.push({ x: canvas.width, type: 'spike' });
                    speed += 0.01;
                }

                // Farba pozadia (Level progress)
                if(currentLevel !== 'endless') {
                    let progress = distance / levels[currentLevel].end;
                    targetBg.r = levels[currentLevel].color[0] * progress + 20;
                    targetBg.g = levels[currentLevel].color[1] * progress + 20;
                    targetBg.b = (255 - levels[currentLevel].color[2] * progress);
                    
                    if(distance > levels[currentLevel].end) {
                        alert("Level Dokon캜en칳!");
                        location.reload();
                    }
                } else {
                    targetBg.r = Math.sin(distance * 0.001) * 50 + 50;
                }

                lerpColor();
            } else {
                // Menu pozadie anim치cia
                distance += 2;
                lerpColor();
            }
        }

        function draw() {
            ctx.fillStyle = `rgb(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Zem
            ctx.fillStyle = "#111";
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            ctx.strokeStyle = pColor;
            ctx.lineWidth = 4;
            ctx.strokeRect(-10, groundY, canvas.width + 20, 5);

            // Mrie쬶a na zemi pre pocit pohybu
            ctx.strokeStyle = "rgba(255,255,255,0.1)";
            ctx.lineWidth = 1;
            for(let i = 0; i < canvas.width; i += 50) {
                let offset = (distance % 50);
                ctx.beginPath();
                ctx.moveTo(i - offset, groundY);
                ctx.lineTo(i - offset, canvas.height);
                ctx.stroke();
            }

            if(gameState === 'playing') {
                drawCube(player.x, player.y, player.size, player.rotation, pColor, playerFace);

                obstacles.forEach((obs, idx) => {
                    if(currentLevel === 'endless') obs.x -= speed;
                    else obs.x = (obs.x_orig || (obs.x_orig = obs.x)) - (distance - 0); // Fixn치 poz칤cia v leveli
                    
                    let screenX = (currentLevel === 'endless') ? obs.x : obs.x - distance + 400;
                    
                    drawSpike(screenX, groundY, 50);

                    // Kol칤zia
                    let px = player.x + 10;
                    let pw = player.size - 20;
                    if(screenX + 40 > px && screenX + 10 < px + pw && player.y + player.size > groundY - 45) {
                        gameState = 'menu';
                        uiLayer.classList.remove('hidden');
                        alert("BOOM! Sk칰s to znova.");
                        resetGame();
                    }
                });
            } else {
                // Menu animovan치 kocka
                let menuCubeY = groundY - 50 + Math.sin(distance * 0.05) * 20;
                drawCube(canvas.width/2 - 25, menuCubeY, 50, distance, pColor, playerFace);
            }

            requestAnimationFrame(() => {
                update();
                draw();
            });
        }

        // --- OVL츼DANIE ---
        const handleJump = () => {
            if(!player.isJumping && gameState === 'playing') {
                player.vy = jumpPower;
                player.isJumping = true;
            }
        };

        window.addEventListener('keydown', (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') handleJump(); });
        window.addEventListener('mousedown', handleJump);

        // Spustenie anim치cie pozadia
        draw();

    </script>
</body>
</html>
