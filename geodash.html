<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoDash Pro Evolution</title>
    <style>
        :root { --primary: #00f2ff; }
        body { margin: 0; overflow: hidden; font-family: 'Arial Black', sans-serif; background: #000; color: white; }
        
        #ui-layer { position: absolute; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; background: rgba(0,0,0,0.7); z-index: 10; }
        .hidden { display: none !important; }
        
        h1 { font-size: 70px; margin: 0; color: var(--primary); text-shadow: 0 0 20px var(--primary); font-style: italic; }
        .panel { background: rgba(20, 20, 20, 0.9); padding: 30px; border-radius: 20px; border: 2px solid var(--primary); text-align: center; width: 450px; }
        
        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        button { padding: 15px; cursor: pointer; background: var(--primary); border: none; color: black; border-radius: 8px; font-weight: bold; text-transform: uppercase; transition: 0.2s; }
        button:hover { transform: scale(1.05); filter: brightness(1.2); }

        .custom-section { display: flex; justify-content: space-around; margin: 20px 0; background: #333; padding: 10px; border-radius: 10px; }
        .face-opt { font-size: 35px; cursor: pointer; filter: grayscale(1); transition: 0.3s; }
        .face-opt.active { filter: grayscale(0); transform: scale(1.3); }
        
        input[type="color"] { border: none; width: 45px; height: 45px; background: none; cursor: pointer; }

        #progress-container { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 300px; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; display: none; }
        #progress-bar { width: 0%; height: 100%; background: var(--primary); border-radius: 5px; box-shadow: 0 0 10px var(--primary); }
        #percent-text { position: absolute; top: 35px; left: 50%; transform: translateX(-50%); font-size: 14px; display: none; }
    </style>
</head>
<body>

    <div id="progress-container"><div id="progress-bar"></div></div>
    <div id="percent-text">0%</div>

    <div id="ui-layer">
        <h1>GEODASH</h1>
        <div class="panel">
            <div class="custom-section">
                <div class="face-opt active" onclick="setFace('happy', 0)">游땕</div>
                <div class="face-opt" onclick="setFace('neutral', 1)">游땛</div>
                <div class="face-opt" onclick="setFace('sad', 2)">驕좶잺</div>
                <input type="color" id="pColor" value="#00f2ff" onchange="updateColors()">
            </div>
            <div class="btn-grid">
                <button onclick="startGame('level1')">Level 1</button>
                <button onclick="startGame('level2')">Level 2</button>
                <button onclick="startGame('level3')">Level 3</button>
                <button onclick="startGame('endless')" style="background: #ffcc00;">Endless Mode</button>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const progressBar = document.getElementById('progress-bar');
        const progressCont = document.getElementById('progress-container');
        const percentText = document.getElementById('percent-text');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let gameState = 'menu';
        let currentLevel = null;
        let distance = 0;
        let speed = 8;
        let isHoldingJump = false;
        let pColor = "#00f2ff";
        let playerFace = 'happy';
        
        let bgColor = { r: 10, g: 10, b: 20 };
        const groundY = canvas.height * 0.75;

        let player = {
            x: 200, y: 0, size: 50,
            vy: 0, rotation: 0, isJumping: false
        };

        let obstacles = [];

        // Defin칤cia levelov: S = Spike (Trojuholn칤k), B = Block (Kocka na sk치kanie)
        const levelData = {
            level1: { 
                end: 5000, color: [0, 100, 255],
                map: [{x: 800, t:'S'}, {x: 1200, t:'S'}, {x: 1500, t:'B'}, {x: 1550, t:'B'}, {x: 2000, t:'S'}, {x: 2300, t:'B'}, {x: 2600, t:'S'}, {x: 3000, t:'S'}, {x: 3060, t:'S'}, {x: 3500, t:'B'}, {x: 3550, t:'B'}, {x: 3600, t:'B'}]
            },
            level2: { 
                end: 6000, color: [150, 0, 255],
                map: [{x: 800, t:'B'}, {x: 1100, t:'S'}, {x: 1400, t:'S'}, {x: 1460, t:'S'}, {x: 1800, t:'B'}, {x: 1850, t:'B'}, {x: 2200, t:'S'}, {x: 2500, t:'B', h: 100}, {x: 2800, t:'S'}]
            },
            level3: { 
                end: 7000, color: [255, 50, 0],
                map: [{x: 600, t:'S'}, {x: 900, t:'B'}, {x: 1000, t:'B', h: 100}, {x: 1300, t:'S'}, {x: 1600, t:'S'}, {x: 1660, t:'S'}, {x: 1720, t:'S'}, {x: 2000, t:'B'}, {x: 2500, t:'S'}]
            }
        };

        function setFace(face, idx) {
            playerFace = face;
            document.querySelectorAll('.face-opt').forEach((el, i) => el.classList.toggle('active', i === idx));
        }

        function updateColors() {
            pColor = document.getElementById('pColor').value;
            document.documentElement.style.setProperty('--primary', pColor);
        }

        function startGame(mode) {
            gameState = 'playing';
            currentLevel = mode;
            uiLayer.classList.add('hidden');
            progressCont.style.display = 'block';
            percentText.style.display = 'block';
            resetGame();
        }

        function resetGame() {
            distance = 0;
            speed = 8;
            player.y = groundY - 50;
            player.vy = 0;
            player.rotation = 0;
            obstacles = [];
            if(currentLevel !== 'endless') {
                obstacles = JSON.parse(JSON.stringify(levelData[currentLevel].map));
            }
        }

        function drawCube(x, y, size, rot) {
            ctx.save();
            ctx.translate(x + size/2, y + size/2);
            ctx.rotate(rot * Math.PI / 180);
            ctx.shadowBlur = 15; ctx.shadowColor = pColor;
            ctx.fillStyle = pColor;
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.strokeStyle = "white"; ctx.lineWidth = 2;
            ctx.strokeRect(-size/2 + 5, -size/2 + 5, size - 10, size - 10);
            
            // Smajl칤k
            ctx.strokeStyle = "black"; ctx.lineWidth = 3; ctx.beginPath();
            ctx.strokeRect(-12, -15, 2, 6); ctx.strokeRect(10, -15, 2, 6);
            if(playerFace === 'happy') ctx.arc(0, 5, 12, 0.2, Math.PI - 0.2, false);
            else if(playerFace === 'neutral') { ctx.moveTo(-12, 12); ctx.lineTo(12, 12); }
            else ctx.arc(0, 20, 10, 0, Math.PI, true);
            ctx.stroke();
            ctx.restore();
            ctx.shadowBlur = 0;
        }

        function update() {
            if(gameState !== 'playing') return;

            distance += speed;
            
            // Auto-jump mechanika
            if(isHoldingJump && !player.isJumping) {
                player.vy = -15;
                player.isJumping = true;
            }

            player.vy += 0.9; // Gravit치cia
            player.y += player.vy;

            let onObject = false;

            // Kol칤zia so zemou
            if(player.y > groundY - player.size) {
                player.y = groundY - player.size;
                player.vy = 0;
                player.isJumping = false;
                player.rotation = Math.round(player.rotation / 90) * 90;
            }

            // Prek치쬶y a bloky
            obstacles.forEach(obs => {
                let obsX = obs.x - distance + 400;
                let obsY = groundY - (obs.h || 50);
                
                if(obs.t === 'S') { // Trojuholn칤k
                    if(player.x + 40 > obsX && player.x + 10 < obsX + 40 && player.y + 40 > groundY - 45) {
                        gameOver();
                    }
                } else if(obs.t === 'B') { // Blok
                    if(player.x + player.size > obsX && player.x < obsX + 50) {
                        // Dopad na blok
                        if(player.y + player.size >= obsY && player.y + player.size <= obsY + 20 && player.vy >= 0) {
                            player.y = obsY - player.size;
                            player.vy = 0;
                            player.isJumping = false;
                            onObject = true;
                            player.rotation = Math.round(player.rotation / 90) * 90;
                        } 
                        // N치raz do boku bloku
                        else if(player.y + player.size > obsY + 10) {
                            gameOver();
                        }
                    }
                }
            });

            if(player.isJumping) player.rotation += 5;

            // Progress bar a farby
            if(currentLevel !== 'endless') {
                let progress = Math.min((distance / levelData[currentLevel].end), 1);
                progressBar.style.width = (progress * 100) + "%";
                percentText.innerText = Math.floor(progress * 100) + "%";
                
                let target = levelData[currentLevel].color;
                bgColor.r += (target[0] * progress/4 - bgColor.r) * 0.05;
                bgColor.g += (target[1] * progress/4 - bgColor.g) * 0.05;
                bgColor.b += (target[2] * progress/4 + 20 - bgColor.b) * 0.05;

                if(distance >= levelData[currentLevel].end) victory();
            } else {
                if(Math.random() < 0.015) {
                    let type = Math.random() > 0.3 ? 'S' : 'B';
                    obstacles.push({x: distance + canvas.width, t: type});
                }
                percentText.innerText = "SCORE: " + Math.floor(distance/10);
            }
        }

        function gameOver() {
            gameState = 'menu';
            uiLayer.classList.remove('hidden');
            alert("Crash! Sk칰s to znova.");
            resetGame();
        }

        function victory() {
            gameState = 'menu';
            uiLayer.classList.remove('hidden');
            alert("LEVEL COMPLETE! Si borec.");
            resetGame();
        }

        function draw() {
            ctx.fillStyle = `rgb(${bgColor.r}, ${bgColor.g}, ${bgColor.b})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Zem
            ctx.fillStyle = "#0a0a0a";
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            ctx.strokeStyle = pColor; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0, groundY); ctx.lineTo(canvas.width, groundY); ctx.stroke();

            // Vykreslenie prek치쬺k
            obstacles.forEach(obs => {
                let screenX = obs.x - distance + 400;
                if(screenX < -100 || screenX > canvas.width + 100) return;

                if(obs.t === 'S') {
                    ctx.fillStyle = "#333"; ctx.strokeStyle = "#ff4444";
                    ctx.beginPath();
                    ctx.moveTo(screenX, groundY); ctx.lineTo(screenX + 50, groundY); ctx.lineTo(screenX + 25, groundY - 50);
                    ctx.closePath(); ctx.fill(); ctx.stroke();
                } else {
                    ctx.fillStyle = "#444"; ctx.strokeStyle = "white";
                    ctx.fillRect(screenX, groundY - (obs.h || 50), 50, (obs.h || 50));
                    ctx.strokeRect(screenX, groundY - (obs.h || 50), 50, (obs.h || 50));
                }
            });

            // Cie쬺v치 stena
            if(currentLevel !== 'endless') {
                let finishX = levelData[currentLevel].end - distance + 400;
                let grad = ctx.createLinearGradient(finishX, 0, finishX + 50, 0);
                grad.addColorStop(0, pColor); grad.addColorStop(1, "transparent");
                ctx.fillStyle = grad;
                ctx.fillRect(finishX, 0, 100, groundY);
            }

            drawCube(player.x, player.y, player.size, player.rotation);

            update();
            requestAnimationFrame(draw);
        }

        // Ovl치danie
        const setJump = (val) => { isHoldingJump = val; };
        window.addEventListener('keydown', (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') setJump(true); });
        window.addEventListener('keyup', (e) => { if(e.code === 'Space' || e.code === 'ArrowUp') setJump(false); });
        window.addEventListener('mousedown', () => setJump(true));
        window.addEventListener('mouseup', () => setJump(false));

        draw();
    </script>
</body>
</html>
